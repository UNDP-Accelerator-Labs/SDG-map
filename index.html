<html>

<head>
	<link rel='stylesheet' type='text/css' href='css/main.css'>
	<link rel='stylesheet' type='text/css' href='css/footer.css'>
	<link rel='stylesheet' type='text/css' href='css/loader.css'>
	<script src='https://cdn.jsdelivr.net/npm/d3@5'></script>
	<script src='https://d3js.org/d3-selection-multi.v1.min.js'></script>
	
	<script type='text/javascript' src='js/d3.prototype.extensions.js'></script>
	<script type='text/javascript' src='js/main.js'></script>
	<script type='text/javascript' src='js/sdg_mapping.js'></script>

	<link rel='icon' type='image/x-icon' href='favicon.ico'>

</head>

<body id='packs'>


<div class='container'>
	<div class='left-col'>
		<header>
			<nav id='languages'></nav>
			<div id='logo'>
				<img src='imgs/branding/UNDP_accelerator_labs_logo_vertical_color_RGB.png'>
				<h1>Action Learning Plans</h1>
				<h2>SDG Browser</h2>
			</div>

			<script type='text/javascript'>
				function fixLabel (node) {
					d3.select(node).classed('has-value', node.value?.trim().length)
				}
			</script>
		</header>
		<svg id='bubbles'>
			<g></g>
		</svg>
		<div class='cartouche'>
			<button type='button' class='expand-filters' onclick='expandfilters(this)'>
				<div class='line l1'></div><div class='line l2'></div><div class='line l3'></div>
			</button>
			<form method='GET'>
				<section>
					<!-- <input id='find-tag' type='text' oninput='highlightTag(this.value)' /> -->
					<div class='filter regions'>
						<input type='text' id='f-regions' onblur='fixLabel(this)'>
						<label for='f-regions'>Filter by region</label>
						<div class='dropdown'>
							<menu class='f-regions'>
							</menu>
						</div>
					</div>
					<div class='filter countries'>
						<input type='text' id='f-countries' onblur='fixLabel(this)'>
						<label for='f-countries'>Filter by country</label>
						<div class='dropdown'>
							<menu class='f-countries'>
							</menu>
						</div>
					</div>
				</section>
				<section>
					<!-- <div class='filter countries'>
						<input type='text' id='h-countries' onblur='fixLabel(this)'>
						<label for='h-countries'>Highlight countries</label>
						<div class='dropdown'>
							<menu class='h-countries'>
							</menu>
						</div>
					</div> -->
					<div class='filter tags'>
						<input type='text' id='h-tags' onblur='fixLabel(this)'>
						<label for='h-regions'>Highlight tags</label>
						<div class='dropdown'>
							<menu class='h-tags'>
							</menu>
						</div>
					</div>
				</section>
				<button type='submit' class='submit-filters'>Apply filters</button>
			</form>
		</div>
		<!-- <button id='get-data'>Get data</button> -->
	</div>
	<div class='right-col'>
		<button type='button' class='expand-filters' onclick='clearPanel()'>
			<div class='line l1'></div><div class='line l2'></div><div class='line l3'></div>
		</button>
	</div>
</div>

<footer>
	<div class='footer-row'>
		<div class='footer-column left'>
			<div class='outer'>
				<img class='logo' src='imgs/branding/UNDP_accelerator_labs_logo_vertical_white.png' alt='UNDP accelerator labs logo'>
				<small>UNDP Accelerator Labs</small>
			</div>
			<div class='inner'>
				<h3>Links</h3>
				<!-- TO DO: TRANSLATE -->
				<ul>
					<li>
						<a target='_blank' href='https://www.undp.org/acceleratorlabs'>
						About Us
						</a>
						<!-- TO DO: TRANSLATE -->
					</li>
					<li>
						<a target='_blank' href='https://www.undp.org/accountability/audit/investigations'>
						Report fraud, abuse, misconduct
						<!-- TO DO: TRANSLATE -->
						</a>
					</li>
					<li>
						<a target='_blank' href='https://www.undp.org/scam-alert'>
						Scam Alert
						<!-- TO DO: TRANSLATE -->
						</a>
					</li>
					<li>
						<a target='_blank' href='https://www.undp.org/copyright-terms-use'>
						Terms of Use
						<!-- TO DO: TRANSLATE -->
						</a>
					</li>
					<li>
						<a target='_blank' href='https://forms.office.com/Pages/ResponsePage.aspx?id=Xtvls0QpN0iZ9XSIrOVDGbiZROH1lsFMla8_BsgmZ6lUOU1SNkVFWkRCVkFaTzBVWExSNkwyNkJGNi4u'>
						Submit a request about our platforms
						<!-- TO DO: TRANSLATE -->
						</a>
					</li>
				</ul>
			</div>
		</div>
		<div class='footer-column center'>
			<div class='inner'>
				<h3>Our Partners</h3>
				<!-- TO DO: TRANSLATE -->
				<img class='footer-img' src='imgs/branding/UNDP_Acc_Labs_All_Partners_horiz_white.png'	alt='UNDP accelerator Partnerslogo'>
			</div>
		</div>
		<div class='footer-column right'>
			<div class='inner'>
				<!-- <h3>Follow Us</h3>
				<div class='social-media-links'>
					<ul>
						<li>
							<a target='_blank' href='https://www.linkedin.com/company/undp-accelerator-labs'>
								<i class='fa fa-linkedin' > </i>
							</a>
						</li>
						<li>
							<a target='_blank' href='https://twitter.com/UNDPAccLabs'>
								<i class='fa fa-twitter'> </i>
							</a>
						</li>
						<li>
							<a target='_blank' href='https://www.instagram.com/acceleratorlabs/'>
								<i class='fa fa-instagram'> </i>
							</a>
						</li>
					</ul>
				</div> -->
			</div>
		</div>
	</div>
	<div class='footer-row signature'>
		<div class='inner'>
			<p>&copy; 2023 United Nations Development Programme</p>
		</div>
		<!-- TO DO: TRANSLATE -->
	</div>
</footer>




<script type='text/javascript'>
	const { clientWidth: cw, clientHeight: ch, offsetWidth: ow, offsetHeight: oh } = d3.select('.left-col').node()
	const width = Math.round(Math.min(cw ?? ow, ch ?? oh))
	const height = width
	const padding = 60
	const edit_layout = false

	const colors = {
	  'dark-blue': '#005687',
	  'mid-blue': '#0468B1',
	  'mid-blue-semi': 'rgba(4,104,177,.75)',
	  'light-blue': '#32BEE1',

	  'dark-red': '#A51E41',
	  'mid-red': '#FA1C26',
	  'light-red': '#F03C8C',

	  'dark-green': '#418246',
	  'mid-green': '#61B233',
	  'light-green': '#B4DC28',

	  'dark-yellow': '#FA7814',
	  'mid-yellow': '#FFC10E',
	  'light-yellow': '#FFF32A',

	  'dark-grey': '#000000',
	  'mid-grey': '#646464',
	  'light-grey': '#969696',
	};
	const sdgcolors = [
		'#E5233B', // 1
		'#DDA839', // 2
		'#4D9F39', // 3
		'#C5182D', // 4
		'#FF3B21', // 5
		'#25BDE2', // 6
		'#FCC30C', // 7
		'#A21842', // 8
		'#FD6924', // 9
		'#DD1267', // 10
		'#FD9D25', // 11
		'#BE8B2F', // 12
		'#3F7E44', // 13
		'#0C97D9', // 14
		'#56C02A', // 15
		'#02689D', // 16
		'#18486A', // 17
	]
	
	const svg = d3.select('svg#bubbles')
	.attrs({ 
		'x': 0,
		'y':0,
		'viewBox': `0 0 ${width} ${height}`,
		'preserveAspectRatio': 'xMidYMid meet'
	})

	const token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1dWlkIjoiNDVlMThiYzMtODgwNS00NWUxLThjNTQtYjM1NmJjZWU0OTEyIiwicmlnaHRzIjozLCJpYXQiOjE2OTk3MDQwOTksImF1ZCI6InVzZXI6a25vd24iLCJpc3MiOiJzZGctaW5ub3ZhdGlvbi1jb21tb25zLm9yZyJ9.vKYu1PcT5Z672GUOuxO4ux_E6MTd2PT-GPBgXPgXbl8'
	
	const platform = new URL('https://learningplans.sdg-innovation-commons.org')
	const tags_path = new URL('apis/fetch/tags', platform)
	const regions_path = new URL('apis/fetch/regions', platform)
	const countries_path = new URL('apis/fetch/countries', platform)

	const basetags_params = new URLSearchParams(tags_path.search)
	basetags_params.append('token', token)
	basetags_params.append('type', 'sdgs')
	let mobilization = 28

	const highlighttags_params = new URLSearchParams(basetags_params)
	new URLSearchParams(window.location.search).forEach((v, k) => {
		if (['countries'].includes(k)) basetags_params.append(k, v)
		if (['regions'].includes(k)) basetags_params.append(k, v)
		if (['mobilizations'].includes(k)) basetags_params.append(k, v) //mobilization = v
	})
	if (!basetags_params.has('mobilizations')) basetags_params.append('mobilizations', mobilization)

	const regions_params = new URLSearchParams(regions_path)
	regions_params.append('token', token)
	const countries_params = new URLSearchParams(countries_path)
	countries_params.append('token', token)
	countries_params.append('has_lab', true)

	const data_collection = []
	data_collection.push(GET(`${tags_path.origin}${tags_path.pathname}?${basetags_params.toString()}`))
	data_collection.push(GET(`${regions_path.origin}${regions_path.pathname}?${regions_params.toString()}`))
	data_collection.push(GET(`${countries_path.origin}${countries_path.pathname}?${countries_params.toString()}`))
	data_collection.push(d3.json('data/taxonomy_manual_202311.json'))
	if (highlighttags_params.size >= 2) data_collection.push(GET(`${tags_path.origin}${tags_path.pathname}?${highlighttags_params.toString()}`))

	addLoader()


	// LOAD PADS
	const pads_path = new URL('apis/fetch/pads', platform)
	const pads_queryparams = new URLSearchParams(pads_path.search)
	pads_queryparams.append('output', 'json')
	pads_queryparams.append('token', token)

	// pads_queryparams.append('countries', 'json')
	if (basetags_params.getAll('mobilizations').length) {
		basetags_params.getAll('mobilizations').forEach(d => {
			pads_queryparams.append('mobilizations', d)
		})
	} else pads_queryparams.append('mobilizations', mobilization)
	pads_queryparams.append('include_imgs', true)
	pads_queryparams.append('include_tags', true)
	new URLSearchParams(window.location.search).forEach((v, k) => {
		if (['countries'].includes(k)) pads_queryparams.append(k, v)
		if (['regions'].includes(k)) pads_queryparams.append(k, v)

	})

	Promise.all([ GET(`${pads_path}?${pads_queryparams}`) ])
	.then(results => {
		const [ pads ] = results

		const nodes = pads.flat().map(d => {
			const sdgs = d.tags?.filter(c => c.type === 'sdgs').map(c => c.key)
			return sdgs.map(c => {
				return { sdg: c, pad: d.pad_id }
			})

		}).flat()
		.nest('sdg')
		.map(d => {
			return { id: d.key, count: d.count }
		})
		console.log(nodes)

		const links = []

		pads.flat().forEach(d => {
			const sdgs = d.tags?.filter(c => c.type === 'sdgs').map(c => c.key)
			sdgs.forEach(c => {
				const connections = sdgs.filter(b => b !== c)
				connections.forEach(b => {
					if (links.some(a => {
						return (a.source === c && a.target === b) ||
						(a.source === b && a.target === c)
					})) {
						const link = links.find(a => {
							return (a.source === c && a.target === b) ||
							(a.source === b && a.target === c)
						})
						link.count ++
					} else {
						links.push({ source: c, target: b, count: 1 })
					}
				})
			})
		})
		console.log(links)

		drawEdgeBundle(nodes, links, pads)
		rmLoader()

	}).catch(err => console.log(err))

	/*
	Promise.all(data_collection)
	.then(results => {
		rmLoader()
		let [ tags_data, regions, countries, taxonomy, tags_portfolio ] = results

		// nodes
			// id: sdgs
		// links
			// source: sdgA
			// target: sdgB
			// value: # of pads connecting the two sdgs

		tags_data.forEach(d => {
			d.key = sdgMap.get(d.id)
		})
		tags_data.sort((a, b) => a.id - b.id)
		let packdata = tags_data.nest('key')
		packdata.forEach(d => {
			d.id = d.key
			d.count = d3.sum(d.values, c => c.count)
			delete d.key
		})

		renderMenu(regions, countries, tags_data)

		const selectids = tags_data.map(d => d.id)
		const portfolio_ids = tags_portfolio?.unique('id', true) || []
		

		// THIS IS TO MAKE SURE ALL TAGS ARE ACCOUNTED FOR (THERE MAY BE NEW TAGS SINCE THE AGGREGATOR WAS LAST RUN)
		tags_data.forEach(d => {
			if (d.count === undefined) d.count = 1
			if (!taxonomy.map(d => d.id).flat().includes(d.id)) {
				console.log('found a missing tag in the taxonomy')
				if (d.name) {
					const obj = {}
					obj.clean = [d.name?.replace(/\./g, ',')]
					obj.clusters = -1
					obj.id = [d.id]
					obj.keywords = taxonomy.find(c => c.clusters === -1).keywords
					obj.split = d.name?.replace(/\./g, ',')
					obj.total_count = d.count // nestedtags.find(c => d.id === c.key).count
					taxonomy.push(obj)
				} else console.log('the tag has no name (value)')
			}
		})

		taxonomy.forEach((d, i) => {
			d.initial_idx = i
		})
		
		// const packdata = JSON.parse(JSON.stringify(taxonomy))
		// .filter(d => {
		// 	return d.id.intersection(selectids).length
		// })
		// packdata.forEach(d => {
		// 	d.select_count = tags_data.find(c => d.id.includes(c.id))?.count ?? 0
		// 	d.highlight = portfolio_ids.some(c => d.id.includes(c)) || false
		// })
		// console.log(packdata)

		// const contains_unclustered = packdata.some(d => d.clusters === -1)

		packdata.forEach(d => {
			d.orid = d.id
			d.id = `root.true.${tags_data.find(c => c.key === d.id).name}`
			d.value = d.count
		})
		packdata.push({ id: 'root.true' })
		packdata.push({ id: 'root' })
		
		drawPack(packdata)

		d3.select('#get-data')
		.on('click', _ => {
			const newdata = d3.selectAll('.node').data().filter(d => !d.children).map(d => d.data)
			taxonomy.forEach(d => {
				const source = newdata.find(c => c.initial_idx === d.initial_idx)
				if (source && d.clusters !== source.clusters) {
					d.clusters = source.clusters
					d.keywords = source.keywords
				}
			})
			console.log(taxonomy)
		})
	}).catch(err => console.log(err))
	*/

	function renderMenu (regions, countries, tags) {
		// ADD THE mobilizations VALUES FOR NOW AS WE DO NOT ENABLE SELECTION YET
		const cartouche = d3.select('.cartouche')
		const form = cartouche.select('form')

		form.addElems('input', 'mobilizations', basetags_params.getAll('mobilizations'))
			.attrs({
				'type': 'hidden',
				'name': 'mobilizations',
				'value': d => d
			})

		// ADD THE DROPDOWNS
		regions.sort((a, b) => a.undp_region.localeCompare(b.undp_region))
		countries = countries.filter(d => {
			if (basetags_params.getAll('regions').length) return d.has_lab && basetags_params.getAll('regions').includes(d.undp_region)
			else return d.has_lab
		})

		tags.sort((a, b) => a.name?.localeCompare(b.name))
		
		// FOR FILTERING
		const regions_menu = cartouche.select('menu.f-regions')
		.addElems('li', 'region', regions)
		
		regions_menu.addElems('input')
			.attrs({
				'type': 'checkbox',
				'value': d => d.undp_region,
				'id': d => d.undp_region,
				'name': 'regions',
				'checked': d => basetags_params.getAll('regions').includes(d.undp_region) || null
			})
		regions_menu.addElems('label')
			.attr('for', d => d.undp_region)
		.html(d => `${d.undp_region_name} (${d.undp_region})`)

		const countries_menu = cartouche.select('menu.f-countries')
		.addElems('li', 'country', countries)
		
		countries_menu.addElems('input')
			.attrs({
				'type': 'checkbox',
				'value': d => d.iso3,
				'id': d => d.iso3,
				'name': 'countries',
				'checked': d => basetags_params.getAll('countries').includes(d.iso3) || null
			})
		countries_menu.addElems('label')
			.attr('for', d => d.iso3)
		.html(d => `${d.country}`)

		// FOR HIGHLIGHTING
		// const countries_hmenu = cartouche.select('menu.h-countries')
		// .addElems('li', 'country', countries)
		
		// countries_hmenu.addElems('input')
		// 	.attrs({
		// 		'type': 'checkbox',
		// 		'value': d => d.iso3,
		// 		'id': d => `h-${d.iso3}`,
		// 		'name': 'countries',
		// 		'checked': d => highlighttags_params.getAll('h-countries').includes(d.iso3) || null
		// 	})
		// countries_hmenu.addElems('label')
		// 	.attr('for', d => `h-${d.iso3}`)
		// .html(d => `${d.country}`)

		const tags_hmenu = cartouche.select('menu.h-tags')
		.addElems('li', 'tag', tags)
		
		tags_hmenu.addElems('input')
			.attrs({
				'type': 'checkbox',
				'value': d => d.name?.simplify(),
				'id': d => d.name?.simplify(),
				'name': 'h-tags',
				'checked': d => highlighttags_params.getAll('h-tag').includes(d.name?.simplify()) || null
			})
		.on('change', function (d) {
			toggleHighlight(d.name, this.checked)
		})

		tags_hmenu.addElems('label')
			.attr('for', d => d.name?.simplify())
		.html(d => d.name)

		// INTERACTIVITY
		cartouche.selectAll('.filter input[type=text]')
		.on('keyup', function () {
			const node = this
			const dropdown = d3.select(node).findAncestor('filter').select('.dropdown')
			dropdown.selectAll('menu li')
				.classed('hide', function () {
					return !this.textContent.trim().toLowerCase()
					.includes(node.value.trim().toLowerCase())
				})
		}).on('focus', function () {
			const dropdown = d3.select(this).findAncestor('filter').select('.dropdown')
			let { top, height } = this.getBoundingClientRect()
			top = top + height
			const viewheight = window.innerHeight
			if (top + 300 >= viewheight) dropdown.classed('dropup', true)

			const filters = d3.select(this).findAncestor('filters')

			if (dropdown.node()) dropdown.node().style.maxHeight = `${Math.min(dropdown.node().scrollHeight, 300)}px`
			if (filters?.node()) filters.node().style.overflow = 'visible'

			dropdown.selectAll('label, a').on('mousedown', function () {
				d3.event.preventDefault()
			})
		}).on('blur', function () {
			const filter = d3.select(this).findAncestor('filter')
			const dropdown = filter.select('.dropdown')
			if (dropdown.node()) dropdown.node().style.maxHeight = null
		})
	}

	function drawEdgeBundle (nodes, links, pads) {
		const polarToCartesian = function (angle, length, offset) {
			if (!offset) offset = [0, 0];
			const x = Math.cos(angle) * length + offset[0];
			const y = Math.sin(angle) * length + offset[1];
			return [x, y];
		};
		const getPosition = function (i, distance) {
			const angle = (360 * i / nodes.length) * Math.PI / 180 - Math.PI / 2
			const length = Math.min(width, height) * distance
			const offset = [ width / 2, height / 2 ]
			return polarToCartesian(angle, length, offset)
		};
		const chunk = function (arr, size) {
			const groups = [];
			for (let i = 0; i < arr.length; i += size) {
				groups.push(arr.slice(i, i + size));
			}
			return groups;
		};

		const nodeScale = d3.scaleLinear()
			.domain(d3.extent(nodes, d => d.count))
			.range([30, 60])
		const linkScale = d3.scaleLinear()
			.domain(d3.extent(links, d => d.count))
			.range([1, 10])

		const g = svg.styles({
			'width': `calc(100% - ${padding}px)`,
			'height': `calc(100% - ${padding}px)`,
		}).select('g')

		const link = g.addElems('path', 'link', links)
			.attr('d', d => {
				const source = getPosition(d.source - 1, .3)
				const target = getPosition(d.target - 1, .3)
				return `M ${source.join(' ')} Q ${width / 2} ${height / 2} ${target.join(' ')}`
			}).styles({
				'stroke': colors['light-grey'],
				'stroke-opacity': .5,
				'stroke-width': d => linkScale(d.count),
				'fill': 'none',
			})

		const node = g.addElems('g', 'node', nodes.sort((a, b) => a.id - b.id))
			.attr('transform', d => {
				const pos = getPosition(d.id - 1, .3)
				return `translate(${pos})`
			})
		node.addElems('circle')
			.attrs({ 
				'r': d => nodeScale(d.count), 
				'title': d => d.id
			})
			.style('fill', d => {
				return sdgcolors[d.id - 1]
			})
		node.addElems('image')
			.attrs({
				'href': d => `imgs/sdgs/G${d.id}-l.svg`,
				'width': d => nodeScale(d.count),
				'height': d => nodeScale(d.count),
				'x': d => -nodeScale(d.count) / 2,
				'y': d => -nodeScale(d.count) / 2,
			})

		const txtvars = { fontsize: 10, dy: 1.4 }
		const titlevars = { fontsize: 18, dy: 1.3 }

		const snippet = g.addElems('g', 'snippet', _ => {
			return nodes.filter(d => [1, 5, 8, 11, 13, 17].includes(d.id))
			.map(d => {
				const pad = pads.flat().shuffle()
				.find(c => {
					return c.tags?.some(b => b.type === 'sdgs' && b.key === d.id) && c.snippet && c.vignette && !c.title.includes('â€¦')
				})

				const title = pad.title.split(' ')
				const tlines = chunk(title, 3)

				const snippet = pad.snippet.split(' ')
				let lines = chunk(snippet, 5)
				if (lines.length > 5) {
					lines = lines.slice(0, 5)
					lines.push(['...'])
				}

				const angle = (360 * d.id / nodes.length)
				let anchor = 'start'
				if (angle > 180) anchor = 'end'
				let pos = getPosition(d.id - 1, .4)
				if (angle < 90 || angle > 270) {
					pos[1] -= (txtvars.fontsize * txtvars.dy * (lines.length + .5)) + (titlevars.fontsize * titlevars.dy * tlines.length)
				}
				return { id: d.id, pad, pos, anchor, lines, tlines }
			})
		}).attr('transform', d => `translate(${d.pos})`)
		snippet.addElems('text', 'title')
			.addElems('tspan', null, d => {
				return d.tlines.map(c => {
					return { line: c, anchor: d.anchor, id: d.id }
				})
			}).attrs({
				'x': 0,
				'dy': titlevars.fontsize * titlevars.dy,
			}).styles({
				'font-size': `${titlevars.fontsize}px`,
				'font-weight': 'bold',
				'text-anchor': d => d.anchor,
				'fill': d => sdgcolors[d.id - 1]
			})
			.text(d => d.line.join(' '))
		snippet.addElems('text', 'description')
			.attr('transform', d => `translate(0, ${d.tlines.length * titlevars.fontsize * titlevars.dy + txtvars.fontsize * txtvars.dy * .5})`)
			.addElems('tspan', null, d => {
				return d.lines.map(c => {
					return { line: c, anchor: d.anchor }
				})
			}).attrs({
				'x': 0,
				'dy': txtvars.fontsize * txtvars.dy,
			}).style('text-anchor', d => d.anchor)
			.text(d =>  d.line.join(' '))
	}

	function drawGraph (nodes, links) {
		const w = width
		const h = height
		const g = svg.styles({
			'width': `calc(100% - ${padding}px)`,
			'height': `calc(100% - ${padding}px)`,
			// 'margin': `${padding}px 0 0 ${padding}px`
		}).select('g')

		const nodeScale = d3.scaleLinear()
			.domain(d3.extent(nodes, d => d.count))
			.range([30, 60])
		const linkScale = d3.scaleLinear()
			.domain(d3.extent(links, d => d.count))
			.range([1, 20])

		// nodes.sort((a, b) => a.count - b.count)
		// const links = graph.links.filter(d => d.weight > .5 || d.weight < -.5)

		const simulation = d3.forceSimulation(nodes)
			.force('charge', d3.forceManyBody())//.strength(-3000))
			.force('center', d3.forceCenter(width / 2, height / 2))
			.force('x', d3.forceX(width / 2).strength(1))
			.force('y', d3.forceY(height / 2).strength(1))
			.force('link', d3.forceLink(links).id(d => d.id).distance(500).strength(1))
			.on('tick', ticked)

		simulation.nodes(nodes)
		simulation.force('link').links(links)

		function ticked () {
			g.addElems('line', 'link', links, d => `${d.source.id}-${d.target.id}`)
				.attrs({ 
					'x1': d => d.source.x, 
					'x2': d => d.target.x, 
					'y1': d => d.source.y, 
					'y2': d => d.target.y 
				}).styles({ 
					'stroke': colors['mid-blue'], 
					'stroke-opacity': .75, 
					'stroke-width': d => linkScale(d.count),
					'pointer-events': 'none' 
				})

			const node = g.addElems('g', 'node', nodes, d => d.id)
				.attr('transform', d => `translate(${[d.x, d.y]})`)
			.on('mouseover', function (d) {
				const sel = d3.select(this).moveToFront()
				const parent = d3.select(this.parentNode)
				sel.select('text').classed('hide', false)
				sel.select('rect').classed('hide', false)
					.attr('width', sel.select('text').node().getBBox().width + 10)
				parent.selectAll('line.link')
					.style('stroke', '#CCC')
			})
			.on('mouseout', function () {
				const sel = d3.select(this)
				const parent = d3.select(this.parentNode)
				sel.select('text').classed('hide', true)
				sel.select('rect').classed('hide', true)
				parent.selectAll('line.link').style('stroke', '#CCC')
			})
			node.addElems('circle')
				.attrs({ 
					'r': d => nodeScale(d.count), 
					'title': d => d.id
				})
				.style('fill', d => {
					return sdgcolors[d.id - 1]
				})
			node.addElems('image')
				.attrs({
					'href': d => `imgs/sdgs/G${d.id}.svg`,
					'width': d => nodeScale(d.count),
					'height': d => nodeScale(d.count),
					'x': d => -nodeScale(d.count) / 2,
					'y': d => -nodeScale(d.count) / 2,
				})

			// <image href="mdn_logo_only_color.png" height="200" width="200" />
			node.addElems('text', 'hide')
				.attrs({ 
					'x': d => nodeScale(d.count) + 5, 
					'alignment-baseline': 'middle' 
				})
				.styles({ 'font-size': '.75rem', 'fill': '#333', 'pointer-events': 'none' })
				.text(d => d.id)
			node.insertElems('text', 'rect', 'hide')
				.attrs({ 
					'width': 0, 
					'height': 20, 
					'y': -10, 
					'x': d => nodeScale(d.count) 
				}).styles({ 
					'fill': '#FFF', 
					'fill-opacity': .9, 
					'pointer-events': 'none' 
				})
		}
	}

	function drawTimeSeries (data) {
		const panel = d3.select('.right-col .inner')
		const { clientWidth: cw, clientHeight: ch, offsetWidth: ow, offsetHeight: oh } = panel.node()
		const width = Math.round(Math.min(cw ?? ow, ch ?? oh))
		const height = Math.round(width * .25)
		const padding = 15

		const svg = panel.addElems('svg')
			.attrs({ 
				'id': 'timeseries',
				width,
				height
			})

		const x = d3.scaleTime()
			.domain(d3.extent(data, d => d.date))
			.range([ padding, width - padding ])
		const y = d3.scaleLinear()
			.domain(d3.extent(data, d => d.count))
			.range([ height - padding, padding ])
		const line = d3.line()
			// .curve(d3.curveMonotone)
			.x(d => x(d.date))
			.y(d => y(d.count))

		svg.addElems('path', 'timeseries', [data])
			.attr('d', line)
	}

	function displaySnippets (kwargs) {
		const { title, data, timeseries } = kwargs
		const container = d3.select('.right-col')
		.style('flex', '1 1 0')
		container.select('button.expand-filters').toggleClass('close')

		const panel = container.addElems('div', 'inner')

		panel.addElems('h1', 'category', title ? [title] : [])
			.html(d => d)

		drawTimeSeries(timeseries)

		const pad = panel.addElems('article', 'pad', data)
		.on('mouseover', function (d) {
			const tags = d.tags.filter(c => c.type === 'thematic_areas')
			const tag_ids = tags.map(c => c.tag_id)
			// DIM ALL NODES THAT ARE NOT IN THE PAD
			d3.selectAll('g.node--leaf circle')
			.filter(c => c.data.orid.intersection(tag_ids).length === 0)
			.classed('dimmed', true)

			d3.selectAll('.group-label')
			.classed('hide', true)

			d3.selectAll('.leaf-label')
			.classed('hide', c => c.data.orid.intersection(tag_ids).length === 0)

			drawPortfolio(tag_ids)

		}).on('mouseout', _ => {
			// UNDIM ALL NODES
			d3.selectAll('g.node--leaf circle')
			.classed('dimmed', false)

			d3.selectAll('.group-label')
			.classed('hide', false)

			d3.selectAll('.leaf-label')
			.classed('hide', true)

			d3.selectAll('path.portfolio').remove()
		}).addElems('div', 'inner')
	
		const head = pad.addElems('hgroup', 'head')

		head.addElems('h1', 'title')
			.addElems('a')
		.attrs({
			'href': d => new URL(`en/view/pad?id=${d.pad_id}`, platform),
			'target': '_blank'
		}).html(d => d.title)
		head.addElems('p', 'country')
			.html(d => d.country)
		head.addElems('small', 'date')
			.html(d => {
				const date = new Date(d.created_at)
				const year = date.getFullYear()
				let month = date.getMonth() + 1
				if (month < 10) month = `0${month}`
				return `${year}-${month}`
			})
		head.addElems('div', 'tags', d => [d.tags.filter(c => c.type === 'thematic_areas')])
			.addElems('div', 'tag', d => d)
			.html(d => d.name?.length > 20 ? `${d.name?.slice(0, 20)}...` : d.name)

		const body = pad.addElems('div', 'body')
		body.addElems('img', 'vignette', d => d.media.slice(0, 1))
			.attr('src', d => d.replace('https:/', 'https://'))
		body.addElems('p', 'snippet', d => [d.snippet])
			.html(d => d)
	}

	function clearPanel () {
		const container = d3.select('.right-col')
		.style('flex', '0 1 0')
		container.select('button.expand-filters').toggleClass('close')
		container.selectAll('.inner').remove()
	}

	function drawPortfolio (data) {
		const points = data.map(d => {
			const circle = d3.selectAll('g.node--leaf').filter(c => c.data.orid.includes(d))
			if (circle.node()) return [ circle.datum().x, circle.datum().y ]
			else return null
		}).filter(d => d)

		svg.addElems('path', 'portfolio', [sortpolygon(points)])
			.attrs({
				'd': d => `M${d.join(' L')}`
			}).styles({
				'stroke': '#000',
				'fill': 'none'
			}).on('click', d => {
				// window.open(`https://acclabs-actionlearningplans.azurewebsites.net/en/edit/pad?id=${data.unique('pad', true)[0]}`, '_blank')
				window.open(`https://learningplans.sdg-innovation-commons.org/en/edit/pad?id=${data.unique('pad', true)[0]}`, '_blank')
			})
	}

	function highlightTag (value) {
		d3.selectAll('circle')
		.classed('highlight', d => value?.length && Object.keys(d.data).includes('orid') && d.data.clean[0].includes(value))
	}
	function toggleHighlight (value, highlight = true) {
		d3.selectAll('circle')
		.filter(d => value?.length && Object.keys(d.data).includes('orid') && d.data.clean[0].includes(value))
		.classed('highlight', highlight)
	}

	function sortpolygon (points, type) {
		if (!points.length) return points
		const unique = []
		points.forEach(d => {
			if (!unique.map(c => c.join('-')).includes(d.join('-'))) unique.push(d)
		})

		// INSPIRED BY https://stackoverflow.com/questions/14263284/create-non-intersecting-polygon-passing-through-all-given-points
		// FIND THE LEFT MOST POINT p AND TH RIGHT MOST POINT q
		const p = unique.sort((a, b) => a[0] - b[0])[0]
		const q = unique.sort((a, b) => b[0] - a[0])[0]
		// CONSIDERING THE FUNCTIONS THAT DEFINE THE pq SEGMENT IS
		// a * x + b
		const a = (p[1] - q[1]) / (p[0] - q[0])
		const b = p[1] - a * p[0]
		// FIND THE GROUP A OF POINTS ABOVE pq
		// A POINT (x, y) IS ABOVE pq IF y > ax + b
		// SEE https://math.stackexchange.com/questions/324589/detecting-whether-a-point-is-above-or-below-a-slope
		const A = unique.filter(d => d[1] > a * d[0] + b)
		A.sort((a, b) => a[0] - b[0])
		// AND THE GROUPP B OF POINTS BELOW pq
		const B = unique.filter(d => d[1] <= a * d[0] + b && ![p.join('-'), q.join('-')].includes(d.join('-')))
		B.sort((a, b) => b[0] - a[0])

		let sorted = [p]
		sorted = sorted.concat(A)
		sorted.push(q)
		sorted = sorted.concat(B)

		return sorted
	}

	function addLoader () {
		const ripple = d3.select('body').addElems('div', 'lds-default')
		ripple.addElems('div', 'filler', d3.range(12))
	}
	function rmLoader () {
		d3.select('.lds-default').remove()
	}
	function expandfilters (node) {
		d3.select(node).toggleClass('close')
		const cartouche = d3.select(node).findAncestor('cartouche')
		const filters = cartouche.select('form').node()
		const padding = filters.querySelector('section').getBoundingClientRect().height / 2
		// WE NEED TO MANUALLY ADD THE BOTTOM PADDING BECAUSE IT IS NOT COMPUTED IN THE scrollHeight
		if (filters.style.maxHeight) {
			filters.style.maxHeight = null
			filters.style.overflow = 'hidden'
		} else {
			filters.style.maxHeight = `${filters.scrollHeight + padding}px`
			filters.style.overflow = 'visible'
		}
	}
	Array.prototype.shuffle = function () {
	  let currentIndex = this.length;
	  let temporaryValue;
	  let randomIndex;

	  while (0 !== currentIndex) {
	    randomIndex = Math.floor(Math.random() * currentIndex);
	    currentIndex -= 1;
	    temporaryValue = this[currentIndex];
	    this[currentIndex] = this[randomIndex];
	    this[randomIndex] = temporaryValue;
	  }
	  return this;
	};
</script>
</body>